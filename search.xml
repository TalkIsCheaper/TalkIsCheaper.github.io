<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式分类</title>
      <link href="/2019/06/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/"/>
      <url>/2019/06/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式 :"></a>创建型模式 :</h2><p>关注对象创建的过程，描述的是如何将对象的创建和使用分离，让用户在使用对象时无需关心对象的创建细节，从而降低系统的耦合度，让设计更加易于修改和扩展。</p><table><thead><tr><th>模式名称</th><th align="left">定义</th><th>学习难度</th><th>使用频率</th></tr></thead><tbody><tr><td>简单工厂模式</td><td align="left">定义一个工厂类，他可以根据参数的不同返回不同类的实例，被创建的实例通常都具有相同的父类</td><td>**</td><td>***</td></tr><tr><td>工厂方法模式</td><td align="left">定义一个用于创建对象的接口，但是让子类决定哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类</td><td>**</td><td>*****</td></tr><tr><td>抽象工厂模式</td><td align="left">提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类</td><td>****</td><td>*****</td></tr><tr><td>建造者模式</td><td align="left">将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</td><td>****</td><td>**</td></tr><tr><td>原型模式</td><td align="left">使用原型实例指定待创建对象的类型，并且通过复制这个原型俩创建新的对象</td><td>***</td><td>***</td></tr><tr><td>单例模式</td><td align="left">确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例</td><td>*</td><td>****</td></tr></tbody></table><h2 id="结构型模式："><a href="#结构型模式：" class="headerlink" title="结构型模式："></a>结构型模式：</h2><p>关注如何将现有类或对象组织在一起形成更加强大的结构，在Gof中一共包含了7中结构型设计模式。</p><p>在面向对象软件系统中，每个类/对象都承担了一定的职责，它们可以相互协作，实现一些复杂的功能。不同的结构型模式从不同的角度来组合类或对象，它们在尽可能满足各种面系那个对象设计原则的同时为类或对象的组合提供一系列巧妙的解决方案。</p><table><thead><tr><th>模式名称</th><th>定义</th><th>学习难度</th><th>使用频率</th></tr></thead><tbody><tr><td>适配器模式</td><td>将一个类的接口转换成客户希望的另一个接口，适配器模式让那些接口不兼容的类可以一起工作</td><td>**</td><td>****</td></tr><tr><td>桥接模式</td><td>将抽象部分与它的实现部分解耦，使得两者都能够独立变化</td><td>***</td><td>***</td></tr><tr><td>组合模式</td><td>组合多个对象形成树形结构以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象</td><td>***</td><td>****</td></tr><tr><td>装饰模式</td><td>动态的给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比子类更加灵活的替代方案</td><td>***</td><td>***</td></tr><tr><td>外观模式</td><td>为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</td><td>*</td><td>*****</td></tr><tr><td>享元模式</td><td>运用共享技术有效地支持大量细粒度对象的复用</td><td>****</td><td>*</td></tr><tr><td>代理模式</td><td>给某一个对象提供一个代理或占位符，并由代理对象来控制原对象的访问</td><td>***</td><td>****</td></tr></tbody></table><h2 id="行为模式："><a href="#行为模式：" class="headerlink" title="行为模式："></a>行为模式：</h2><p>行为模式关注系统对象之间的交互，研究系统在运行时对象之间的相互通信与协作，进一步明确对象的职责。共有11中。</p><p>在软件系统运行时对象并不是孤立存在的，它们可以通过相互的通信协作完成某些功能，一个对象在运行时也将影响其他对象的运行。行为模式不仅仅关注类和对象本身，还重点关注它们之间的相互作用和职责划分。</p><table><thead><tr><th>模式名称</th><th>定义</th><th>学习难度</th><th>使用频率</th></tr></thead><tbody><tr><td>职责链模式</td><td>避免一个请求的发送者与接受者耦合在一起，让多个对象都有机会处理请求。将接受请求的对象连接成一条链，并且沿着这条链传递请求，知道有一个对象能够处理它为止</td><td>***</td><td>**</td></tr><tr><td>命令模式</td><td>将一个请求封装成一个对象，从而可以用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销操作</td><td>***</td><td>****</td></tr><tr><td>解释器模式</td><td>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子</td><td>*****</td><td>*</td></tr><tr><td>迭代器模式</td><td>提供一种方法顺序访问一个聚合对象中的各个元素，而又不用暴露该对象的内部表示</td><td>***</td><td>*****</td></tr><tr><td>中介者模式</td><td>定义一个对象来封装一系列对象的交互。中介者模式使得各个对象之间不需要显示的相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</td><td>***</td><td>**</td></tr><tr><td>备忘录模式</td><td>在不破坏封装的前提下捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态</td><td>**</td><td>**</td></tr><tr><td>观察者模式</td><td>定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时其相关依赖对象皆得到通知并被自动更新</td><td>***</td><td>*****</td></tr><tr><td>状态模式</td><td>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类</td><td>***</td><td>***</td></tr><tr><td>策略模式</td><td>定义一系列算法，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法可以独立于使用它的客户端而变化</td><td>*</td><td>****</td></tr><tr><td>模板方法模式</td><td>定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可以冲定义该算法的某些特定步骤</td><td>**</td><td>***</td></tr><tr><td>访问者模式</td><td>表示一个作用于某对象结构中的各个元素的操作。访问者模式让用户可以在不改变各元素的类的前提下定义作用于这些元素的新操作</td><td>****</td><td>*</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> gof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-面向对象设计原则</title>
      <link href="/2019/06/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2019/06/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="7个常用的面向对象设计模式"><a href="#7个常用的面向对象设计模式" class="headerlink" title="7个常用的面向对象设计模式"></a>7个常用的面向对象设计模式</h2><hr><h3 id="1、单一职责原则"><a href="#1、单一职责原则" class="headerlink" title="1、单一职责原则"></a>1、单一职责原则</h3><p>解释：<strong>一个对象应该只包含单一的职责，并且该职责被完整的封装在一个类中。</strong></p><p>  一个类承担的职责越多，那么它被复用的可能性就越小，且职责过多时，会将过的职责耦合在一起，当一个职责发生变化时，会影响其他职责的运行。</p><p>单一原则是实现高内聚、低耦合的指导方针。所以我们应该尽可能的发现累的不同职责并将它们分离出来。</p><h3 id="2、开闭原则"><a href="#2、开闭原则" class="headerlink" title="2、开闭原则"></a>2、开闭原则</h3><p>解释：<strong>软件实体应该对扩展开放，对修改关闭</strong>。</p><p>指的就是软件实体应该在尽量不修改原有代码的情况下进行扩展。</p><p>为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键所在。通过定义系统的抽象层，在通过具体类进行扩展。如果需要修改系统的行为，无需对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可。开闭原则是系统是否具有良好的扩展性和灵活性的重要判断依据。</p><h3 id="3、里氏代换原则"><a href="#3、里氏代换原则" class="headerlink" title="3、里氏代换原则"></a>3、里氏代换原则</h3><p>解释：<strong>所有引用基类的地方必须能够透明地使用其子类的对象。</strong></p><p>里氏代换原则表明，在软件中讲一个基类对象替换成它的子类对象，程序不会产生任何错误和异常，反过来则不成立。</p><p>里氏代换原则是实现开闭原则的重要方式之一，由于在使用基类对象的地方，都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时在确定其子类类型，用子类对象替换父类对象。<strong>在运用里氏代换原则时应该将父类设计为抽象类或者接口。</strong></p><h3 id="4、依赖倒转原则"><a href="#4、依赖倒转原则" class="headerlink" title="4、依赖倒转原则"></a>4、依赖倒转原则</h3><p>解释：<strong>高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</strong></p><p>简单解释就是：要求<strong>针对接口编程，不要针对实现编程。</strong></p><p>依赖倒转原则要求在传递参数时或者关联关系中尽量引用层次高的抽吸那个类，即使用接口和抽象类进行<strong>变量类型声明</strong>，<strong>参数类型声明</strong>，<strong>方法返回声明</strong>，以及<strong>数据类型转换</strong> ，而<em>不要</em>用具体的类来做这些事。</p><p><strong>为了确保该原则的应用，一个具体类应当只实现接口或者抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法</strong></p><h3 id="开闭原则是目标、里氏代换原则是基础、依赖倒转原则是手段，三者相辅相成，相互补充，目标一致，只是分析问题时所站的位置不同。"><a href="#开闭原则是目标、里氏代换原则是基础、依赖倒转原则是手段，三者相辅相成，相互补充，目标一致，只是分析问题时所站的位置不同。" class="headerlink" title="开闭原则是目标、里氏代换原则是基础、依赖倒转原则是手段，三者相辅相成，相互补充，目标一致，只是分析问题时所站的位置不同。"></a>开闭原则是目标、里氏代换原则是基础、依赖倒转原则是手段，三者相辅相成，相互补充，目标一致，只是分析问题时所站的位置不同。</h3><h3 id="5、接口隔离原则"><a href="#5、接口隔离原则" class="headerlink" title="5、接口隔离原则"></a>5、接口隔离原则</h3><p>解释：<strong>客户端不应该依赖那些它不需要的接口。</strong><br><strong>当一个接口太大时，需要将它分割成一些更小的接口，使用该接口的客户端仅仅需要知道与之相关的方法即可。</strong></p><p>（1）当把“接口”理解成一个类型所提供的所有方法特征的集合时，这是一种逻辑上的概念，接口的划分将直接带来类型的划分，》》》》》》“角色隔离原则”</p><p>（2）把“接口”理解成狭义的特定语言的接口，那么接口隔离原则指的是仅仅提供客户端需要的行为，为客户端提供尽可能小的单独的接口，而不要提供大的接口。接口应当尽量的细化，同时接口中的方法应当尽量的少，每个接口只包含一个客户端（如子模块或者业务逻辑类）所需的方法即可，即是为不同的客户端提供宽窄不同的接口。</p><p>使用接口隔离原则时候需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口的泛滥，不利于维护；同时若果接口过大，灵活性较差，使用起来很不方便。一般而言：在接口中仅仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些他们不需要的方法。</p><h3 id="6、合成复用原则"><a href="#6、合成复用原则" class="headerlink" title="6、合成复用原则"></a>6、合成复用原则</h3><p>解释：<strong>优先使用对象组合，而不是通过集成来达到复用的目的。</strong></p><p>合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有的对象的方法达到复用功能的目的。简而言之，在复用时应当尽量使用组合/聚合关系（has - a），少用继承（is - a）。</p><p>通过继承完成复用时，子类会破坏系统的封装性，因为<strong>继承会将基类的实现细节暴露给子类</strong>，相对于子类来说是可见的，这种复用称之为“<strong>白箱复用</strong>”，</p><p>组合/聚合关系是将已有的对象纳入新的对象中，成为新对象的一部分，因此新对象可以调用已有对象的功能，同时成员对象的内部实现对于新对象是不可见的，所以这种复用称之为“<strong>黑箱复用</strong>”。相对于继承而言，耦合度较低，成员对象的变化对于新对象的影响不大，可以在新对象中根据实际需要有选择的调用成员对象的操作。</p><h3 id="7、迪米特法则（最少知道原则）"><a href="#7、迪米特法则（最少知道原则）" class="headerlink" title="7、迪米特法则（最少知道原则）"></a>7、迪米特法则（最少知道原则）</h3><p>解释：<strong>每一个软件单位对于其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。</strong></p><p>迪米特法则要求一个软件实体应当尽可能少的与其他实体发生相互作用。当软件中某一个模块发生修改时应当尽量少的影响其他模块。应用<strong>迪米特法则可以降低系统的耦合度，使类与类之间保持松散的耦合关系</strong>。</p><p>在一个对象中，其朋友包含以下几类：</p><p>（1）当前对象本身</p><p>（2）以参数形式传入到当前对象方法中的对象</p><p>（3）当前对象的成员对象</p><p>（4）如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友</p><p>（5）当前对象所创建的对象</p><p>在运用迪米特法则时注意一下四点：</p><p>1、在类的划分上应当尽量创建松耦合的类，耦合度越低，越利于复用。</p><p>2、每一个类都应当尽量降低其成员变量和成员函数的访问权限</p><p>3、只要有可能，一个类型应当设计成不变类</p><p>4、一个对象对其他对象的引用应当降到最低</p>]]></content>
      
      
      
        <tags>
            
            <tag> Gof </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
